var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage and Examples","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Following a walkthrough of the package and the features. An AttributeGraph is quite straightforwardingly defined by 4 fields:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"the underlying wrapped graph\nthe vertex attribute data structure\nthe edge attribute data structure\nthe graph attribute data structure","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"That is because we tried to manufacture the least speculative way to define a such. As this might not be able to do some easy out-of-the-box operations we also proposed a more Opinionated approach","category":"page"},{"location":"usage/#Opinionated-approach","page":"Usage and Examples","title":"Opinionated approach","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The default operation of AttributeGraphs is an opinionated one. By calling AttributeGraph(), you are already within the realm of our preferences.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> using AttributeGraphs, Graphs\n\njulia> AttributeGraph() |> typeof\nAttributeGraph{Int64, SimpleGraph{Int64}, Vector{Missing}, Dict{Tuple{Int64, Int64, Int64}, Missing}, Missing}","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"This approach treats graph data as following:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The vertex attributes data structure is a vector. ","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The index of the vector corresponds to the index of the vertex. This way we want to be closer to the Graphs.jl implementation.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The edge attributes data structure is a Dict{Tuple{Int, Int, Int}}.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Non surpisingly, each edge attribute is indexed by the source and destination node. The third integer is the multiplicity for MultiGraphs and if non given, 1 is assumed.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The graph attributes data structure is non existent. The user type is directly what it is.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"However some functionality is provided from {add,rem,has,get}graphattr[!] for AbstractDict. For trivial situation you should directly use graph_attr.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Following we define a AttributeGraph with vertex and edge attributes of String and graph attributes of Dict{Symbol, String}","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> oag = AttributeGraph(;vvertex_type=String, edge_type=String, graph_type=Dict{Symbol, String})\n{0, 0} undirected attribute Int64 graph\n","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"You will not be surpised to see that probably all of the obvious operations are supported.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"For example starting with the graph attributes","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> addgraphattr!(oag, :ena, \"ena\")\n\"ena\"\n\njulia> addgraphattr!(oag, :dio, \"dio\")\n\"dio\"\n\njulia> graph_attr(oag)\nDict{Symbol, String} with 2 entries:\n  :ena => \"ena\"\n  :dio => \"dio\"","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Now let's add some vertices and edges. Note we use the addvertex!, [addedge](@ref) and friends instead ofaddvertex!,addedge!` and friends to be 100% consistent. The second ones will also work, but you sooner or later you will reach a corrupted state.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> foreach(_ -> addvertex!(oag), 1:10) # add 10 nodes\n\njulia> foreach(x -> addedge!(oag,x[1],x[2]), [(1,2), (1,3), (3,4), (1,5), (7,8)]) # add some edges","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"addvertex! immeadiately adds missing to the vertex attribute:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> vertex_attr(oag)\n10-element Vector{Union{Missing, String}}:\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing\n missing","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> addvertexattr!(oag, 4, \"customattr4\")\n\"customattr4\"\n\njulia> vertex_attr(oag)\n10-element Vector{Union{Missing, String}}:\n missing\n missing\n missing\n \"customattr4\"\n missing\n missing\n missing\n missing\n missing\n missing","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Similar for edge attributes:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> addedgeattr!(oag, 1, 2, \"data_for_1-2\")\n\"data_for_1-2\"\n\njulia> addedgeattr!(oag, 3, 4, \"data_for_3-4\")\n\"data_for_3-4\"\n\njulia> edge_attr(oag)\nDict{Tuple{Int64, Int64, Int64}, String} with 2 entries:\n  (1, 2, 1) => \"data_for_1-2\"\n  (3, 4, 1) => \"data_for_3-4\"","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Deleting a node will automatically update the indices and attributes","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> remvertex!(oag, 2)\ntrue\n\njulia> edge_attr(oag)\nDict{Tuple{Int64, Int64, Int64}, String} with 1 entry:\n  (2, 3, 1) => \"data_for_3-4\"","category":"page"},{"location":"usage/#General-approach","page":"Usage and Examples","title":"General approach","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Basically, AttributeGraph is a parametric type that can be anything. So you can customize it to do whatever you want. You might say that the lack of features is the basic feature here.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The basic use case for this is that you might often have some data data accompanying your graph graph. You don't want to always pass around a tuple of (graph, data). Instead, you can simply use this package to load data in a AttributeGraph and pass it around more compactly.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"An outrageous example follows","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> using DataStructures, Random, Test\n\njulia> Random.seed!(0); # for reproducibility\n\njulia> gag = AttributeGraph(SimpleGraph(), (v) -> v+randn(), DefaultDict{Tuple{Int, Int, String},Float64}(10.0), missing)\n{0, 0} undirected attribute Int64 graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Here the vertex attributes are given by a normally distributed random function with mean the vertex index. The edge attributes are a default dictionary indexed by a tuple {Int, Int, String} The graph attributes are non-existant so we pass in missing.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The following function will return our initializations","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> vertex_attr(gag); # returns a function\n\njulia> edge_attr(gag)\nDataStructures.DefaultDict{Tuple{Int64, Int64, String}, Float64, Float64}()\n\njulia> graph_attr(gag)\nmissing","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"We can continue on constructing our graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertices!(gag, 10)\n10\n\njulia> foreach(v -> add_edge!(gag, v, v+1), 1:nv(gag))\n\njulia> gag \n{10, 9} undirected attribute Int64 graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"You can query right away the vertex stochastic attributes","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> [vertex_attr(gag)(v) for v in vertices(gag)]\n10-element Vector{Float64}:\n 1.9429705334461191\n 2.1339227576531843\n 4.5250689085124804\n 4.123901231205597\n 3.794227715740064\n 6.311817175360248\n 6.76535873503874\n 6.912647706289468\n 9.462310680431376\n 9.919406913366794","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"I hear you saying: \"But I can even do vertex_attr(gag)(1235)\" and it will still return a value even though the vertex doesn't exist. True. You can move on to customize your approach if you want that to fail. Eg:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> myvertexattr(ag::AttributeGraph, x) = has_vertex(ag, x) ? vertex_attr(gag)(x) : error(\"no attribute\")\nmyvertexattr (generic function with 1 method)\njulia> myvertexattr(gag, 4)\n3.187569312095576\n\njulia> @test_throws Exception myvertexattr(gag, 123) # now it throws an error\nTest Passed\n      Thrown: ErrorException","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Similarly you will need to manually fill up the attributes for the graph edge, e.g.:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> let e = first(edges(gag))\n           edge_attr(gag)[src(e), dst(e), \"class1\"] = 100\n           edge_attr(gag)[src(e), dst(e), \"class2\"] = 200\n       end;\n\njulia> edge_attr(gag)\nDefaultDict{Tuple{Int64, Int64, String}, Float64, Float64} with 2 entries:\n  (1, 2, \"class1\") => 100.0\n  (1, 2, \"class2\") => 200.0","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Since we decided to use a DefaultDict though you can still query other edges","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> edge_attr(gag)[1, 4, \"\"]\n10.0","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The general approach is mostly useful for customizable or quick and dirty situations.","category":"page"},{"location":"#AttributeGraphs.jl","page":"Introduction","title":"AttributeGraphs.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AttributeGraphs.jl is an effort to make a dead-simple, type-stable, flexible, customizable and compliant with Graphs.jl container of a graph and its attributes. It wraps an AbstractGraph, thus in theory it can play with all subtypes, and provides API for edge, vertices and graph attributes. The type of attributes is parametric.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To access the attributes you can use `vertexattr(), edgeattr(), graph_attr().","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An opinionated API using {add,rem,has,get}{graph,vertex,edge}attr[!] is exported, but if not appreciated one can easily create his/her own version. The opinionated implementation uses a Vector for the data attributes of each vertex and a Dict for the edge attributes, to approach the Graphs.jl paradigm as much as possible. The Dict keys are updated after a vertex removal.","category":"page"},{"location":"#Similar-packages-and-differences","page":"Introduction","title":"Similar packages and differences","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MetaGraphs.jl\ntype-unstable\nonly implements SimpleGraph and SimpleDiGraph\nMetaGraphsNext.jl\nuser must define labels for every node\nhardcoded properties types using Dictionaries\nedge properties can only be identified by a tuple of vertices.\nMetaDataGraphs.jl\nsimilar to MetaGraphsNext.jl but graph[label] should return the integer code and not the metadata (to make integration with Graphs.jl easier)","category":"page"},{"location":"#Proposal","page":"Introduction","title":"Proposal","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Go to MetaGraphsNext.jl if:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"you need labels for every node\nthe edge-data is associated only from the source and destination","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Stay here if:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you do not want labels for the vertices, but instead a Graphs.jl feel.\nIf you want to customize the way you handle your attribute data types.\nIf you don't like carrying data around seperately from your graph\nIf you like our opinionated approach","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AttributesGraphs.jl is a simple and small project and might break often in favor of design improvements.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [AttributeGraphs]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"API/#AttributeGraphs.addedgeattr!-Union{Tuple{E}, Tuple{Vr}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge, T, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, Vr, E<:AbstractDict{Kr, Vr}}","page":"API","title":"AttributeGraphs.addedgeattr!","text":"addedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict{Kr, Vr}},\n    e::AbstractEdge,\n    m::Integer,\n    v\n)\n\n\nAdd edge attribute v for edge e and multiplicity m.\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addedgeattr!-Union{Tuple{E}, Tuple{Vr}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, Vr, E<:AbstractDict{Kr, Vr}}","page":"API","title":"AttributeGraphs.addedgeattr!","text":"addedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict{Kr, Vr}},\n    e::AbstractEdge,\n    v\n) -> Any\n\n\nAdd edge attribute v for edge e\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addedgeattr!-Union{Tuple{E}, Tuple{Vr}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T, T, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, Vr, E<:AbstractDict{Kr, Vr}}","page":"API","title":"AttributeGraphs.addedgeattr!","text":"addedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict{Kr, Vr}},\n    s::Integer,\n    d::Integer,\n    m::Integer,\n    v\n)\n\n\nAdd edge attribute v for edge defined by source s, destination d and multiplicity m.\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addedgeattr!-Union{Tuple{E}, Tuple{Vr}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, Vr, E<:AbstractDict{Kr, Vr}}","page":"API","title":"AttributeGraphs.addedgeattr!","text":"addedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict{Kr, Vr}},\n    s::Integer,\n    d::Integer,\n    v\n) -> Any\n\n\nAdd edge attribute v for edge defined by source s and destination d\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addgraphattr!-Union{Tuple{R}, Tuple{Vr}, Tuple{Kr}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, Kr, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, E, Kr, Vr, R<:AbstractDict{Kr, Vr}}","page":"API","title":"AttributeGraphs.addgraphattr!","text":"addgraphattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E, R<:AbstractDict{Kr, Vr}},\n    k,\n    v\n) -> Any\n\n\nAdd a graph attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addvertex!-Union{Tuple{AttributeGraph{T, G, V, E, R}}, Tuple{R}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:AbstractGraph{T}, V<:(AbstractVector), E, R}","page":"API","title":"AttributeGraphs.addvertex!","text":"addvertex!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V<:(AbstractVector), E, R}\n) -> Bool\n\n\nAdd a vertex in the graph and push a missing value to the attributes\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.addvertexattr!-Union{Tuple{Vr}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, Vr}} where {T<:Integer, G<:AbstractGraph{T}, V, E, Vr}","page":"API","title":"AttributeGraphs.addvertexattr!","text":"addvertexattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E},\n    k::Integer,\n    v\n) -> Any\n\n\nAdd vertex attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.edge_attr-Union{Tuple{AttributeGraphs.AbstractAttibuteGraph{T, G}}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:AbstractGraph}","page":"API","title":"AttributeGraphs.edge_attr","text":"edge_attr(\n    mg::AttributeGraphs.AbstractAttibuteGraph{T<:Integer, G<:AbstractGraph}\n) -> Any\n\n\nGet the data structure for all edge attributes\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getedgeattr-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T, T}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.getedgeattr","text":"getedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    s::Integer,\n    d::Integer,\n    m::Integer\n) -> Any\n\n\nGet edge attribute for edge defined by source s and destination d and multiplicity m\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getedgeattr-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.getedgeattr","text":"getedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    s::Integer,\n    d::Integer\n) -> Any\n\n\nGet edge attribute for edge defined by source s and destination d\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getedgeattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge, T}} where {T<:Integer, G<:AbstractGraph{T}, V, E<:AbstractDict}","page":"API","title":"AttributeGraphs.getedgeattr","text":"getedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict},\n    e::AbstractEdge,\n    m::Integer\n) -> Any\n\n\nGet edge attribute for edge defined edge e with multiplicity m\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getedgeattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge}} where {T<:Integer, G<:AbstractGraph{T}, V, E<:AbstractDict}","page":"API","title":"AttributeGraphs.getedgeattr","text":"getedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict},\n    e::AbstractEdge\n) -> Any\n\n\nGet edge attribute for edge defined by e\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getgraph-Union{Tuple{AttributeGraphs.AbstractAttibuteGraph{T, G}}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:AbstractGraph}","page":"API","title":"AttributeGraphs.getgraph","text":"getgraph(\n    mg::AttributeGraphs.AbstractAttibuteGraph{T<:Integer, G<:AbstractGraph}\n) -> Any\n\n\nGet the wrapped graph\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getgraphattr-Union{Tuple{R}, Tuple{Kr}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, Kr}} where {T<:Integer, G<:AbstractGraph{T}, V, E, Kr, R<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.getgraphattr","text":"getgraphattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E, R<:(AbstractDict{Kr})},\n    k\n) -> Any\n\n\nGet graph attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.getvertexattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T}} where {T<:Integer, G<:AbstractGraph{T}, V, E}","page":"API","title":"AttributeGraphs.getvertexattr","text":"getvertexattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E},\n    k::Integer\n) -> Any\n\n\nGet vertex attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.graph_attr-Union{Tuple{AttributeGraphs.AbstractAttibuteGraph{T, G}}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:AbstractGraph}","page":"API","title":"AttributeGraphs.graph_attr","text":"graph_attr(\n    mg::AttributeGraphs.AbstractAttibuteGraph{T<:Integer, G<:AbstractGraph}\n) -> Any\n\n\nGet the data structure for all graph attributes\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasedgeattr-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, Tuple}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.hasedgeattr","text":"hasedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    ktup::Tuple\n) -> Any\n\n\nCheck if edge has attribute for edge defined by the tuple ktup\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasedgeattr-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, Vararg{T}}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.hasedgeattr","text":"hasedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    args::T<:Integer...\n) -> Any\n\n\nCheck if edge has attribute for edge defined by the arguments args given as a tuple\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasedgeattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge, T}} where {T<:Integer, G<:AbstractGraph{T}, V, E<:AbstractDict}","page":"API","title":"AttributeGraphs.hasedgeattr","text":"hasedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict},\n    e::AbstractEdge,\n    m::Integer\n) -> Any\n\n\nCheck if edge has attribute for edge e and multiplicity m\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasedgeattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge}} where {T<:Integer, G<:AbstractGraph{T}, V, E<:AbstractDict}","page":"API","title":"AttributeGraphs.hasedgeattr","text":"hasedgeattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:AbstractDict},\n    e::AbstractEdge\n) -> Any\n\n\nCheck if edge has attribute for edge e\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasgraphattr-Union{Tuple{R}, Tuple{Kr}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, Kr}} where {T<:Integer, G<:AbstractGraph{T}, V, E, Kr, R<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.hasgraphattr","text":"hasgraphattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E, R<:(AbstractDict{Kr})},\n    k\n) -> Any\n\n\nCheck if graph has this attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.hasvertexattr-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T}} where {T<:Integer, G<:AbstractGraph{T}, V, E}","page":"API","title":"AttributeGraphs.hasvertexattr","text":"hasvertexattr(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E},\n    k::Integer\n) -> Bool\n\n\nCheck if vertex has this attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remedge!-Union{Tuple{R}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, T, T}, Tuple{AttributeGraph{T, G, V, E, R}, T, T, T}} where {T<:Integer, G<:AbstractGraph{T}, V<:(AbstractVector), E<:(AbstractDict{<:Tuple{T, T, T}}), R}","page":"API","title":"AttributeGraphs.remedge!","text":"remedge!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V<:(AbstractVector), E<:(AbstractDict{<:Tuple{T<:Integer, T<:Integer, T<:Integer}}), R},\n    s::Integer,\n    d::Integer\n)\nremedge!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V<:(AbstractVector), E<:(AbstractDict{<:Tuple{T<:Integer, T<:Integer, T<:Integer}}), R},\n    s::Integer,\n    d::Integer,\n    m::Integer\n)\n\n\nRemove an edge from the graph and update attributes and keys/indices\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remedgeattr!-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge, T}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.remedgeattr!","text":"remedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    e::AbstractEdge,\n    m::Integer\n) -> Any\n\n\nRemove edge attribute for edge e and multiplicity m\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remedgeattr!-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, AbstractEdge}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.remedgeattr!","text":"remedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    e::AbstractEdge\n) -> Any\n\n\nRemove edge attribute for edge e\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remedgeattr!-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T, T}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.remedgeattr!","text":"remedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    s::Integer,\n    d::Integer,\n    m::Integer\n) -> Any\n\n\nRemove edge attribute for edge defined by source s, destination d and multiplicity m.\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remedgeattr!-Union{Tuple{E}, Tuple{Kr}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T, T}} where {T<:Integer, G<:AbstractGraph{T}, V, Kr, E<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.remedgeattr!","text":"remedgeattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E<:(AbstractDict{Kr})},\n    s::Integer,\n    d::Integer\n) -> Any\n\n\nRemove edge attribute for edge defined by source s and destination d\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remgraphattr!-Union{Tuple{R}, Tuple{Kr}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, Kr}} where {T<:Integer, G<:AbstractGraph{T}, V, E, Kr, R<:(AbstractDict{Kr})}","page":"API","title":"AttributeGraphs.remgraphattr!","text":"remgraphattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E, R<:(AbstractDict{Kr})},\n    k\n) -> Any\n\n\nRemove a graph attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remvertex!-Union{Tuple{R}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E, R}, T}} where {T<:Integer, G<:AbstractGraph{T}, V<:(AbstractVector), E<:(AbstractDict{<:Tuple{T, T, T}}), R}","page":"API","title":"AttributeGraphs.remvertex!","text":"remvertex!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V<:(AbstractVector), E<:(AbstractDict{<:Tuple{T<:Integer, T<:Integer, T<:Integer}}), R},\n    u::Integer\n) -> Bool\n\n\nRemove a vertex from the graph and update all attributes and keys/indices\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.remvertexattr!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{T}, Tuple{AttributeGraph{T, G, V, E}, T}} where {T<:Integer, G<:AbstractGraph{T}, V, E}","page":"API","title":"AttributeGraphs.remvertexattr!","text":"remvertexattr!(\n    ag::AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E},\n    k::Integer\n) -> Union{Missing, Nothing}\n\n\nRemove vertex attribute\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.vertex_attr-Union{Tuple{AttributeGraphs.AbstractAttibuteGraph{T, G}}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:AbstractGraph}","page":"API","title":"AttributeGraphs.vertex_attr","text":"vertex_attr(\n    mg::AttributeGraphs.AbstractAttibuteGraph{T<:Integer, G<:AbstractGraph}\n) -> Any\n\n\nGet the data structure for all vertex attributes\n\n\n\n\n\n","category":"method"},{"location":"API/#AttributeGraphs.AttributeGraph","page":"API","title":"AttributeGraphs.AttributeGraph","text":"struct AttributeGraph{T<:Integer, G<:AbstractGraph{T<:Integer}, V, E, R} <: AttributeGraphs.AbstractAttibuteGraph{T<:Integer, G<:AbstractGraph{T<:Integer}}\n\ngraph::AbstractGraph{T} where T<:Integer: the wrapped graph\nvertex_attr::Any: the attributes for the vertices\nedge_attr::Any: the attributes for the edges\ngraph_attr::Any: the attributes for the graph\n\nIf the type for the vertices attributes and the edges attributes is a AbstractVector then there is a default behavior.\n\n\n\n\n\n","category":"type"},{"location":"API/#AttributeGraphs.AttributeGraph-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"API","title":"AttributeGraphs.AttributeGraph","text":"AttributeGraph(\n    gr::AbstractGraph{T<:Integer};\n    vvertex_type,\n    edge_type,\n    graph_type\n) -> AttributeGraph{T, _B, Vector{Missing}, _C, Missing} where {T<:Integer, _B<:AbstractGraph{T}, _C}\n\n\nConstruct an vector-based AttributeGraph. This means that the attributes instances will be vectors corresponding to the edges() and vertices() iterators.\n\nKeywords\n\nvertex_attr_type: The element type for the vertex attributes vector\nedge_attr_type: The element type for the edge attributes Dict. The tuples are the edge details src, dst and mult for edge multiplicity.\n\nEdge multiplicity is always 1 if not interested to this.\n\ngraph_attr_type: The element type for the graph attributes. It needs to be able to call an empty constructor with this.\n\n\n\n\n\n","category":"method"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"}]
}
